apply plugin: 'kotlin'
apply plugin: 'net.corda.plugins.publish-utils'
apply plugin: 'com.jfrog.artifactory'

description 'HA Utilities'

dependencies {
    compile project(':node')
    compile project(':tools:cliutils')
    compile "org.apache.logging.log4j:log4j-slf4j-impl:$log4j_version"

    testCompile(project(':test-utils')) {
        exclude group: 'org.apache.logging.log4j', module: 'log4j-slf4j-impl'
    }

    testCompile(project(':test-cli'))
    testCompile(project(':node-driver'))
    testImplementation "junit:junit:$junit_version"
    testRuntimeOnly "org.junit.vintage:junit-vintage-engine:${junit_vintage_version}"
    testRuntimeOnly "org.junit.platform:junit-platform-launcher:${junit_platform_version}"

    testCompile project(path: ':node-api', configuration: 'testArtifacts')

    testImplementation "io.mockk:mockk:1.9.kotlin12"
}

/*
 * A bit of explanation on the two jar tasks.
 * The ultimate artifact this module needs to produce is a fat jar, that contains the kotlin runtime.
 * This allows the jar to be used as a stand alone tool.
 *
 * However this module is also used as a dependency in another module (:bridge).
 * The kotlin compiler plugin produces a warning in case a dependency jar contains kotlin runtime.
 *
 * Therefore we need a thin jar, that is used by gradle when the module is depended on
 * and we need the fat jar that we already have.
 */
jar {
    // jar by default is thin. adding a classifier, because the unclassified jar needs to be the fat jar.
    archiveClassifier = "thin"
}

task fatJar(type: Jar, dependsOn: jar) {
    // the executable fat jar
    with jar
    from(configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }) {
        exclude "META-INF/*.SF"
        exclude "META-INF/*.DSA"
        exclude "META-INF/*.RSA"
        exclude "META-INF/INDEX.LIST"
        exclude "log4j2.xml"
    }
    baseName = "ha-utilities"
    manifest {
        attributes(
                'Main-Class': 'com.r3.ha.utilities.MainKt'
        )
    }
}
// we need to make sure the fat jar gets published
assemble.dependsOn fatJar
artifacts {
    publish fatJar
}

publish {
    // we dont really need the default (thin) jar to be published
    disableDefaultJar = true
    name 'corda-tools-ha-utilities'
}
