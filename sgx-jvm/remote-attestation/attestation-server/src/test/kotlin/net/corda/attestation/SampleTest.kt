package net.corda.attestation

import org.junit.Assert.*
import org.junit.Before
import org.junit.Test
import java.security.*
import java.security.interfaces.ECPrivateKey
import java.security.interfaces.ECPublicKey
import java.security.spec.*

class SampleTest {
    private companion object {
        private val privateKeyBytesBE = unsignedByteArrayOf(
            0x40, 0x8A, 0x06, 0x1A, 0xE6, 0x81, 0x3A, 0x7B, 0xAC, 0x4E, 0x34, 0xAA, 0x4D, 0x61, 0x3C, 0x86,
            0xF3, 0xDD, 0x9C, 0x48, 0x82, 0xA8, 0x68, 0x57, 0xFC, 0xB3, 0x9D, 0xF9, 0x81, 0xB6, 0x56, 0x2D
        )
        private val publicKeyBytesBE = unsignedByteArrayOf(
            0x39, 0x16, 0xB0, 0x69, 0xB2, 0xBB, 0x0F, 0x92, 0xC4, 0x10, 0x27, 0x30, 0x9E,
            0x45, 0x61, 0x93, 0xB1, 0x67, 0x4F, 0xFB, 0x3E, 0xBC, 0x1F, 0xC5, 0xAE, 0x9F, 0x1A, 0x59, 0x45, 0x9F, 0x8C, 0xC0,
            0x4F, 0x96, 0x00, 0x30, 0x6E, 0x6C, 0x1F, 0x23, 0xF1, 0x5A, 0x2B, 0x1C, 0xC8, 0x32, 0xEB, 0xB8, 0xDC, 0x6A, 0x1A,
            0xA9, 0xE0, 0xCA, 0x35, 0x2A, 0x72, 0x46, 0x52, 0x2B, 0x24, 0x6B, 0x98, 0x5D
        )

        private val privateKeyBytesLE = unsignedByteArrayOf(
            0x90, 0xe7, 0x6c, 0xbb, 0x2d, 0x52, 0xa1, 0xce, 0x3b, 0x66, 0xde, 0x11, 0x43, 0x9c, 0x87, 0xec,
            0x1f, 0x86, 0x6a, 0x3b, 0x65, 0xb6, 0xae, 0xea, 0xad, 0x57, 0x34, 0x53, 0xd1, 0x03, 0x8c, 0x01
        )
        private val publicKeyBytesLE = unsignedByteArrayOf(
            0x72, 0x12, 0x8a, 0x7a, 0x17, 0x52, 0x6e, 0xbf, 0x85, 0xd0, 0x3a, 0x62, 0x37, 0x30, 0xae, 0xad,
            0x3e, 0x3d, 0xaa, 0xee, 0x9c, 0x60, 0x73, 0x1d, 0xb0, 0x5b, 0xe8, 0x62, 0x1c, 0x4b, 0xeb, 0x38,
            0xd4, 0x81, 0x40, 0xd9, 0x50, 0xe2, 0x57, 0x7b, 0x26, 0xee, 0xb7, 0x41, 0xe7, 0xc6, 0x14, 0xe2,
            0x24, 0xb7, 0xbd, 0xc9, 0x03, 0xf2, 0x9a, 0x28, 0xa8, 0x3c, 0xc8, 0x10, 0x11, 0x14, 0x5e, 0x06
        )
    }

    private lateinit var ecParameters: ECParameterSpec
    private lateinit var keyFactory: KeyFactory
    private lateinit var crypto: Crypto

    private lateinit var publicKey: ECPublicKey
    private lateinit var privateKey: ECPrivateKey

    @Before
    fun setup() {
        crypto = Crypto(DummyRandom())
        keyFactory = KeyFactory.getInstance("EC")
        ecParameters = (crypto.generateKeyPair().public as ECPublicKey).params
        publicKey = keyFactory.generatePublic(publicKeyBytesLE.toBigEndianKeySpec(ecParameters)) as ECPublicKey
        privateKey = keyFactory.generatePrivate(ECPrivateKeySpec(privateKeyBytesLE.reversedArray().toPositiveInteger(), ecParameters)) as ECPrivateKey
    }

    @Test
    fun checkKey() {
        val myData = "And now for something completely different!"
        val signature = Signature.getInstance("SHA256WithECDSA").let { signer ->
            signer.initSign(privateKey, crypto.random)
            signer.update(myData.toByteArray())
            signer.sign()
        }
        val verified = Signature.getInstance("SHA256WithECDSA").let { verifier ->
            verifier.initVerify(publicKey)
            verifier.update(myData.toByteArray())
            verifier.verify(signature)
        }
        assertTrue(verified)
    }

    @Test
    fun reversePublicKey() {
        val transformedKey = keyFactory.generatePublic(publicKey.toLittleEndian().toBigEndianKeySpec(ecParameters)) as ECPublicKey
        assertArrayEquals(publicKey.encoded, transformedKey.encoded)
    }
}

fun ByteArray.toKeySpec(ecParameters: ECParameterSpec): KeySpec {
    if (size != KEY_SIZE) {
        throw IllegalArgumentException("Public key has incorrect size ($size bytes)")
    }
    val ecPoint = ECPoint(
        copyOf(size / 2).toPositiveInteger(),
        copyOfRange(size / 2, size).toPositiveInteger()
    )
    return ECPublicKeySpec(ecPoint, ecParameters)
}
