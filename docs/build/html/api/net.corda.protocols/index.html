<HTML>
<HEAD>
<title>net.corda.protocols - </title>
<link rel="stylesheet" href="../style.css">
</HEAD>
<BODY>
<a href=".">net.corda.protocols</a><br/>
<br/>
<h2>Package net.corda.protocols</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<a href="-abstract-state-replacement-protocol/index.html">AbstractStateReplacementProtocol</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">AbstractStateReplacementProtocol</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code><p>Abstract protocol to be used for replacing one state with another, for example when changing the notary of a state.
Notably this requires a one to one replacement of states, states cannot be split, merged or issued as part of these
protocols.</p>
</td>
</tr>
<tr>
<td>
<a href="-broadcast-transaction-protocol/index.html">BroadcastTransactionProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">BroadcastTransactionProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><span class="identifier">Unit</span><span class="symbol">&gt;</span></code><p>Notify all involved parties about a transaction, including storing a copy. Normally this would be called via
<a href="-finality-protocol/index.html">FinalityProtocol</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="-cash-command/index.html">CashCommand</a></td>
<td>
<code><span class="keyword">sealed</span> <span class="keyword">class </span><span class="identifier">CashCommand</span></code><p>A command to initiate the Cash protocol with.</p>
</td>
</tr>
<tr>
<td>
<a href="-cash-protocol/index.html">CashProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">CashProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><a href="-cash-protocol-result/index.html"><span class="identifier">CashProtocolResult</span></a><span class="symbol">&gt;</span></code><p>Initiates a protocol that produces an Issue/Move or Exit Cash transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="-cash-protocol-result/index.html">CashProtocolResult</a></td>
<td>
<code><span class="keyword">sealed</span> <span class="keyword">class </span><span class="identifier">CashProtocolResult</span></code></td>
</tr>
<tr>
<td>
<a href="-fetch-attachments-protocol/index.html">FetchAttachmentsProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">FetchAttachmentsProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-fetch-data-protocol/index.html"><span class="identifier">FetchDataProtocol</span></a><span class="symbol">&lt;</span><a href="../net.corda.core.contracts/-attachment/index.html"><span class="identifier">Attachment</span></a><span class="symbol">,</span>&nbsp;<span class="identifier">ByteArray</span><span class="symbol">&gt;</span></code><p>Given a set of hashes either loads from from local storage  or requests them from the other peer. Downloaded
attachments are saved to local storage automatically.</p>
</td>
</tr>
<tr>
<td>
<a href="-fetch-data-protocol/index.html">FetchDataProtocol</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">FetchDataProtocol</span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.contracts/-named-by-hash/index.html"><span class="identifier">NamedByHash</span></a><span class="symbol">, </span><span class="keyword">in</span>&nbsp;<span class="identifier">W</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><a href="-fetch-data-protocol/-result/index.html"><span class="identifier">Result</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code><p>An abstract protocol for fetching typed data from a remote peer.</p>
</td>
</tr>
<tr>
<td>
<a href="-fetch-transactions-protocol/index.html">FetchTransactionsProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">FetchTransactionsProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-fetch-data-protocol/index.html"><span class="identifier">FetchDataProtocol</span></a><span class="symbol">&lt;</span><a href="../net.corda.core.transactions/-signed-transaction/index.html"><span class="identifier">SignedTransaction</span></a><span class="symbol">,</span>&nbsp;<a href="../net.corda.core.transactions/-signed-transaction/index.html"><span class="identifier">SignedTransaction</span></a><span class="symbol">&gt;</span></code><p>Given a set of tx hashes (IDs), either loads them from local disk or asks the remote peer to provide them.</p>
</td>
</tr>
<tr>
<td>
<a href="-finality-protocol/index.html">FinalityProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">FinalityProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><span class="identifier">Unit</span><span class="symbol">&gt;</span></code><p>Finalise a transaction by notarising it, then recording it locally, and then sending it to all involved parties.</p>
</td>
</tr>
<tr>
<td>
<a href="-notary-change-protocol/index.html">NotaryChangeProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">NotaryChangeProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-abstract-state-replacement-protocol/index.html"><span class="identifier">AbstractStateReplacementProtocol</span></a><span class="symbol">&lt;</span><a href="../net.corda.core.crypto/-party/index.html"><span class="identifier">Party</span></a><span class="symbol">&gt;</span></code><p>A protocol to be used for changing a states Notary. This is required since all input states to a transaction
must point to the same notary.</p>
</td>
</tr>
<tr>
<td>
<a href="-notary-error/index.html">NotaryError</a></td>
<td>
<code><span class="keyword">sealed</span> <span class="keyword">class </span><span class="identifier">NotaryError</span></code></td>
</tr>
<tr>
<td>
<a href="-notary-protocol/index.html">NotaryProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">NotaryProtocol</span></code></td>
</tr>
<tr>
<td>
<a href="-resolve-transactions-protocol/index.html">ResolveTransactionsProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">ResolveTransactionsProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../net.corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../net.corda.core.transactions/-ledger-transaction/index.html"><span class="identifier">LedgerTransaction</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code><p>This protocol is used to verify the validity of a transaction by recursively checking the validity of all the
dependencies. Once a transaction is checked its inserted into local storage so it can be relayed and wont be
checked again.</p>
</td>
</tr>
<tr>
<td>
<a href="-service-request-message/index.html">ServiceRequestMessage</a></td>
<td>
<code><span class="keyword">interface </span><span class="identifier">ServiceRequestMessage</span></code><p>Abstract superclass for request messages sent to services which expect a reply.</p>
</td>
</tr>
<tr>
<td>
<a href="-state-replacement-refused/index.html">StateReplacementRefused</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">StateReplacementRefused</span></code><p>Thrown when a participant refuses the proposed state replacement</p>
</td>
</tr>
<tr>
<td>
<a href="-two-party-deal-protocol/index.html">TwoPartyDealProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">TwoPartyDealProtocol</span></code><p>Classes for manipulating a two party deal or agreement.</p>
</td>
</tr>
<tr>
<td>
<a href="-two-party-trade-protocol/index.html">TwoPartyTradeProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">TwoPartyTradeProtocol</span></code><p>This asset trading protocol implements a "delivery vs payment" type swap. It has two parties (B and S for buyer
and seller) and the following steps:</p>
</td>
</tr>
<tr>
<td>
<a href="-validating-notary-protocol/index.html">ValidatingNotaryProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">ValidatingNotaryProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-notary-protocol/-service/index.html"><span class="identifier">Service</span></a></code><p>A notary commit protocol that makes sure a given transaction is valid before committing it. This does mean that the calling
party has to reveal the whole transaction history; however, we avoid complex conflict resolution logic where a party
has its input states "blocked" by a transaction from another party, and needs to establish whether that transaction was
indeed valid.</p>
</td>
</tr>
</tbody>
</table>
<h3>Exceptions</h3>
<table>
<tbody>
<tr>
<td>
<a href="-input-state-ref-resolve-failed/index.html">InputStateRefResolveFailed</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">InputStateRefResolveFailed</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html"><span class="identifier">Exception</span></a></code></td>
</tr>
<tr>
<td>
<a href="-notary-exception/index.html">NotaryException</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">NotaryException</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html"><span class="identifier">Exception</span></a></code></td>
</tr>
<tr>
<td>
<a href="-state-replacement-exception/index.html">StateReplacementException</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">StateReplacementException</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html"><span class="identifier">Exception</span></a></code></td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="send-request.html">sendRequest</a></td>
<td>
<code><span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">R</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">&gt;</span> <a href="../net.corda.core.messaging/-messaging-service/index.html"><span class="identifier">MessagingService</span></a><span class="symbol">.</span><span class="identifier">sendRequest</span><span class="symbol">(</span><span class="identifier" id="net.corda.protocols$sendRequest(net.corda.core.messaging.MessagingService, kotlin.String, net.corda.protocols.ServiceRequestMessage, net.corda.core.messaging.SingleMessageRecipient)/topic">topic</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span><span class="symbol">, </span><span class="identifier" id="net.corda.protocols$sendRequest(net.corda.core.messaging.MessagingService, kotlin.String, net.corda.protocols.ServiceRequestMessage, net.corda.core.messaging.SingleMessageRecipient)/request">request</span><span class="symbol">:</span>&nbsp;<a href="-service-request-message/index.html"><span class="identifier">ServiceRequestMessage</span></a><span class="symbol">, </span><span class="identifier" id="net.corda.protocols$sendRequest(net.corda.core.messaging.MessagingService, kotlin.String, net.corda.protocols.ServiceRequestMessage, net.corda.core.messaging.SingleMessageRecipient)/target">target</span><span class="symbol">:</span>&nbsp;<a href="../net.corda.core.messaging/-single-message-recipient.html"><span class="identifier">SingleMessageRecipient</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span><span class="symbol">&lt;</span><span class="identifier">R</span><span class="symbol">&gt;</span></code><p>Sends a <a href="-service-request-message/index.html">ServiceRequestMessage</a> to <a href="send-request.html#net.corda.protocols$sendRequest(net.corda.core.messaging.MessagingService, kotlin.String, net.corda.protocols.ServiceRequestMessage, net.corda.core.messaging.SingleMessageRecipient)/target">target</a> and returns a <a href="#">ListenableFuture</a> of the response.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
